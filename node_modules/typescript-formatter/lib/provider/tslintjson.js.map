{"version":3,"file":"tslintjson.js","sourceRoot":"","sources":["tslintjson.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from \"typescript\";\nimport { IOptions as TslintOptions } from \"tslint\";\nimport * as path from \"path\";\n\nimport { Options } from \"../\";\nimport { getConfigFileName } from \"../utils\";\n\n\nexport interface AdditionalFormatSettings {\n    $noConsecutiveBlankLines: boolean;\n}\n\nexport async function makeFormatCodeOptions(fileName: string, opts: Options, formatSettings: ts.FormatCodeSettings): Promise<ts.FormatCodeSettings> {\n\n    const rules = await getRules(fileName, opts);\n\n    if (!rules) {\n        return formatSettings;\n    }\n\n    const indent = rules.get(\"indent\");\n    const whitespace = rules.get(\"whitespace\");\n\n    if (indent && indent.ruleArguments) {\n        switch (indent.ruleArguments[0]) {\n            case \"spaces\":\n                formatSettings.convertTabsToSpaces = true;\n                break;\n            case \"tabs\":\n                formatSettings.convertTabsToSpaces = false;\n                break;\n            default:\n                break;\n        }\n    }\n    if (whitespace && whitespace.ruleArguments) {\n        for (let p in whitespace.ruleArguments) {\n            switch (whitespace.ruleArguments[p]) {\n                case \"check-branch\":\n                    formatSettings.insertSpaceAfterKeywordsInControlFlowStatements = true;\n                    break;\n                case \"check-operator\":\n                    formatSettings.insertSpaceBeforeAndAfterBinaryOperators = true;\n                    break;\n                case \"check-separator\":\n                    formatSettings.insertSpaceAfterCommaDelimiter = true;\n                    formatSettings.insertSpaceAfterSemicolonInForStatements = true;\n                    break;\n                case \"check-typecast\":\n                    formatSettings.insertSpaceAfterTypeAssertion = true;\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n\n    return formatSettings;\n}\n\nexport async function postProcess(fileName: string, formattedCode: string, opts: Options, _formatSettings: ts.FormatCodeSettings): Promise<string> {\n\n    const rules = await getRules(fileName, opts);\n\n    if (!rules) {\n        return formattedCode;\n    }\n\n    if (rules.has(\"no-consecutive-blank-lines\")) {\n        formattedCode = formattedCode.replace(/\\n+^$/mg, \"\\n\");\n    }\n\n    return formattedCode;\n}\n\nasync function getRules(fileName: string, opts: Options): Promise<Map<string, Partial<TslintOptions>> | undefined> {\n    const baseDir = opts.baseDir ? path.resolve(opts.baseDir) : path.dirname(path.resolve(fileName));\n\n    let configFileName: string | null;\n    if (opts.tslintFile && path.isAbsolute(opts.tslintFile)) {\n        configFileName = opts.tslintFile;\n    } else {\n        configFileName = getConfigFileName(baseDir, opts.tslintFile || \"tslint.json\");\n    }\n\n    if (!configFileName) {\n        return undefined;\n    }\n\n    if (opts.verbose) {\n        console.log(`read ${configFileName} for ${fileName}`);\n    }\n\n    const { Configuration } = await import(\"tslint\");\n    const { rules } = Configuration.loadConfigurationFromPath(configFileName);\n    return rules;\n}\n"]}