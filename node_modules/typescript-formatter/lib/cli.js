"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
try {
    require("typescript");
}
catch (e) {
    console.error("typescript is required. please try 'npm install -g typescript'\n");
}
var ts = require("typescript");
var fs = require("fs");
var path = require("path");
var commandpost = require("commandpost");
var lib = require("./");
var utils_1 = require("./utils");
var packageJson = JSON.parse(fs.readFileSync(path.join(__dirname, "../package.json")).toString());
var root = commandpost
    .create("tsfmt [files...]")
    .option("-r, --replace", "replace .ts file")
    .option("--verify", "checking file format")
    .option("--baseDir <path>", "config file lookup from <path>")
    .option("--stdin", "get formatting content from stdin")
    .option("--no-tsconfig", "don't read a tsconfig.json")
    .option("--no-tslint", "don't read a tslint.json")
    .option("--no-editorconfig", "don't read a .editorconfig")
    .option("--no-vscode", "don't read a .vscode/settings.json")
    .option("--no-tsfmt", "don't read a tsfmt.json")
    .option("--useTsconfig <path>", "using specified config file instead of tsconfig.json")
    .option("--useTslint <path>", "using specified config file instead of tslint.json")
    .option("--useTsfmt <path>", "using specified config file instead of tsfmt.json")
    .option("--useVscode <path>", "using specified config file instead of .vscode/settings.json")
    .option("--verbose", "makes output more verbose")
    .option("-v, --version", "output the version number")
    .action(function (opts, args) {
    var replace = !!opts.replace;
    var verify = !!opts.verify;
    var baseDir = opts.baseDir ? opts.baseDir[0] : void 0;
    var stdin = !!opts.stdin;
    var tsconfig = !!opts.tsconfig;
    var tslint = !!opts.tslint;
    var editorconfig = !!opts.editorconfig;
    var vscode = !!opts.vscode;
    var tsfmt = !!opts.tsfmt;
    var tsconfigFile = opts.useTsconfig[0] ? path.join(process.cwd(), opts.useTsconfig[0]) : null;
    var tslintFile = opts.useTslint[0] ? path.join(process.cwd(), opts.useTslint[0]) : null;
    var vscodeFile = opts.useVscode[0] ? path.join(process.cwd(), opts.useVscode[0]) : null;
    var tsfmtFile = opts.useTsfmt[0] ? path.join(process.cwd(), opts.useTsfmt[0]) : null;
    var verbose = !!opts.verbose;
    var version = !!opts.version;
    if (version) {
        console.log("tsfmt : " + packageJson.version);
        console.log("tsc   : " + ts.version);
        return;
    }
    var files = args.files;
    var useTsconfig = false;
    if (files.length === 0) {
        var configFileName = tsconfigFile || utils_1.getConfigFileName(baseDir || process.cwd(), "tsconfig.json");
        if (configFileName) {
            files = utils_1.readFilesFromTsconfig(configFileName);
            if (verbose) {
                console.log("read: " + configFileName);
            }
            useTsconfig = true;
        }
    }
    if (files.length === 0 && !opts.stdin) {
        process.stdout.write(root.helpText() + "\n");
        return;
    }
    if (verbose) {
        var printPool_1 = {};
        var printSetting = function (name, value) {
            if (typeof value === "boolean") {
                printPool_1[name] = value ? "ON" : "OFF";
            }
            else {
                printPool_1[name] = value;
            }
        };
        var doPrint = function () {
            var maxLength = Object.keys(printPool_1).reduce(function (p, c) { return Math.max(p, c.length); }, 0);
            Object.keys(printPool_1).forEach(function (key) {
                var value = printPool_1[key];
                console.log(padSpaces(key, maxLength + 1) + ": " + value);
            });
            function padSpaces(str, len) {
                var result = str;
                while (result.length < len) {
                    result += " ";
                }
                return result;
            }
        };
        printSetting("replace", replace);
        printSetting("verify", verify);
        printSetting("baseDir", baseDir ? baseDir : process.cwd());
        printSetting("stdin", stdin);
        printSetting("files from tsconfig", useTsconfig);
        printSetting("tsconfig", tsconfig);
        if (tsconfigFile) {
            printSetting("specified tsconfig.json", tsconfigFile);
        }
        printSetting("tslint", tslint);
        if (tslintFile) {
            printSetting("specified tslint.json", tslintFile);
        }
        printSetting("editorconfig", editorconfig);
        printSetting("vscode", vscode);
        if (vscodeFile) {
            printSetting("specified vscode settings.json", vscodeFile);
        }
        printSetting("tsfmt", tsfmt);
        if (tsfmtFile) {
            printSetting("specified tsfmt.json", tsfmtFile);
        }
        doPrint();
    }
    if (stdin) {
        if (replace) {
            errorHandler("--stdin option can not use with --replace option");
            return;
        }
        lib
            .processStream(files[0] || "temp.ts", process.stdin, {
            replace: replace,
            verify: verify,
            baseDir: baseDir,
            tsconfig: tsconfig,
            tsconfigFile: tsconfigFile,
            tslint: tslint,
            tslintFile: tslintFile,
            editorconfig: editorconfig,
            vscode: vscode,
            vscodeFile: vscodeFile,
            tsfmt: tsfmt,
            tsfmtFile: tsfmtFile,
            verbose: verbose,
        })
            .then(function (result) {
            var resultMap = {};
            resultMap[result.fileName] = result;
            return resultMap;
        })
            .then(showResultHandler)
            .catch(errorHandler);
    }
    else {
        lib
            .processFiles(files, {
            replace: replace,
            verify: verify,
            baseDir: baseDir,
            tsconfig: tsconfig,
            tsconfigFile: tsconfigFile,
            tslint: tslint,
            tslintFile: tslintFile,
            editorconfig: editorconfig,
            vscode: vscode,
            vscodeFile: vscodeFile,
            tsfmt: tsfmt,
            tsfmtFile: tsfmtFile,
            verbose: verbose,
        })
            .then(showResultHandler)
            .catch(errorHandler);
    }
});
commandpost
    .exec(root, process.argv)
    .catch(errorHandler);
function showResultHandler(resultMap) {
    var hasError = Object.keys(resultMap).filter(function (fileName) { return resultMap[fileName].error; }).length !== 0;
    if (hasError) {
        Object.keys(resultMap)
            .map(function (fileName) { return resultMap[fileName]; })
            .filter(function (result) { return result.error; })
            .forEach(function (result) { return process.stderr.write(result.message); });
        process.exit(1);
    }
    else {
        Object.keys(resultMap)
            .map(function (fileName) { return resultMap[fileName]; })
            .forEach(function (result) {
            if (result.message) {
                process.stdout.write(result.message);
            }
        });
    }
    return Promise.resolve(null);
}
function errorHandler(err) {
    if (err instanceof Error) {
        console.error(err.stack);
    }
    else {
        console.error(err);
    }
    return Promise.resolve(null).then(function () {
        process.exit(1);
        return null;
    });
}
//# sourceMappingURL=cli.js.map